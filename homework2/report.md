# 41343147

作業一 Ackermann Function

## 解題說明

根據數學定義直接轉為程式邏輯。

使用三個條件判斷：

若 m == 0 → 回傳 n + 1。

若 n == 0 → 回傳 A(m - 1, 1)。

否則 → 回傳 A(m - 1, A(m, n - 1))。

遞迴深度極深，需小心 Stack Overflow。

### 解題策略

1. 使用遞迴函式將問題拆解為更小的子問題：
   $$\Sigma(n) = n + \Sigma(n-1)$$
2. 當 $n \leq 1$ 時，返回 $n$ 作為遞迴的結束條件。  
3. 主程式呼叫遞迴函式，並輸出計算結果。

## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

int A(int m, int n) {
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return A(m - 1, 1);
    else
        return A(m - 1, A(m, n - 1));
}

int main() {
    cout << A(1, 2) << endl; // 預期輸出：4
    return 0;
}

```

## 效能分析

1.時間複雜度

Ackermann 函數的成長速度極快，
其遞迴次數遠遠超過多項式或指數等常見函數的增長率，因此無法以封閉式時間複雜度表示。
不過，若將 m 固定於小範圍，可以觀察其具體行為：

當 m = 0 時：僅執行一次簡單加法運算 → 時間為常數階。

當 m = 1 或 m = 2 時：整體運算量與 n 成線性關係。

當 m = 3 時：結果呈指數爆炸（以 2 為底的指數增長）。

當 m ≥ 4 時：遞迴深度與時間成長已遠超指數級，實務上無法計算。

2.空間複雜度

Ackermann 函數的每一層遞迴都會在系統堆疊中保留一個呼叫紀錄。因此其空間使用量與遞迴深度呈正比。  

當輸入的 `m` 與 `n` 增加時，堆疊深度急劇增加，最終可能導致 **Stack Overflow**。

由於每一層的狀態（m, n）需保留至子呼叫完成後才能回傳，故堆疊深度與遞迴層數呈正比。

以下為不同 `m` 值下的近似空間複雜度：
| m | 主要成長形態 | 空間複雜度 | 備註 |
|:-:|:--|:--|:--|
| 0 | 常數 | `O(1)` | 無遞迴呼叫 |
| 1 | 線性 | `O(n)` | 呼叫深度約等於 n |
| 2 | 線性 | `O(n)` | 每層結束即返回 |
| 3 | 指數 | `O(2^n)` | 呼叫深度隨結果倍增 |
| ≥4 | 超指數 | 無法估計 | 系統堆疊極速溢出 |

## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $n$ | 預期輸出 | 實際輸出 |
|:--------:|:------------:|:--------:|:--------:|
| 測試一 | $n = 0$ | 0 | 0 |
| 測試二 | $n = 1$ | 1 | 1 |
| 測試三 | $n = 3$ | 6 | 6 |
| 測試四 | $n = 5$ | 15 | 15 |
| 測試五 | $n = -1$ | 異常拋出 | 異常拋出 |


### 編譯與執行指令
```shell
$ g++ Problem1-1.cpp -std=c++14 -o Problem1-1 (Visual Studio 2022 為C+14)
$ Problem1-1.exe
4
```

### 結論

1.在撰寫 Ackermann 函數的過程中，我是根據題目給的定義式，直接把三種情況分別寫進遞迴函式裡：  
`m == 0` 回傳 `n + 1`，`n == 0` 呼叫 `A(m - 1, 1)`，其他情況則是再呼叫一次 `A(m - 1, A(m, n - 1))`。  

2.實作時可以明顯感受到這題的遞迴層數非常深，雖然在小數值下（像 `(1,2)`、`(2,2)`、`(3,2)`）都能正確算出結果，但只要 `m` 稍微變大，執行時間就會變得非常慢，甚至造成 **Stack Overflow**。  

3.這題讓我更清楚理解「遞迴呼叫其實就是一層層函式堆疊」的概念，每一次的呼叫都必須等內層結束才能往回傳值。  
雖然這個函數在實務上不太會被用到，但它很好地展示了遞迴的運作方式，以及遞迴演算法的極限。
## 申論及開發報告

### 選擇遞迴的原因

在這題中，我選擇使用遞迴的主要原因是 Ackermann 函數本身就是用遞迴定義的。  
用遞迴方式撰寫可以讓程式的結構幾乎完全對應數學公式，每一個條件判斷都能清楚表示出函式的三種情況。  

1. **程式邏輯簡單直觀**  
  Ackermann 函數的數學定義本身就是一種典型的遞迴關係式，使用遞迴實作能自然地表達「將問題拆解為更小的子問題」這個核心概念。



3. **易於理解與實現**  
   遞迴的程式碼更接近數學公式的表示方式，特別適合新手學習遞迴的基本概念。  
   以本程式為例：  

   ```cpp
   int sigma(int n) {
       if (n < 0)
           throw "n < 0";
       else if (n <= 1)
           return n;
       return n + sigma(n - 1);
   }
   ```

