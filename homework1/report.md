# 41343147

作業一 Ackermann Function

## 解題說明

根據數學定義直接轉為程式邏輯。

使用三個條件判斷：

若 m == 0 → 回傳 n + 1。

若 n == 0 → 回傳 A(m - 1, 1)。

否則 → 回傳 A(m - 1, A(m, n - 1))。

遞迴深度極深，需小心 Stack Overflow。

### 解題策略

1. 使用遞迴函式將問題拆解為更小的子問題：
   $$\Sigma(n) = n + \Sigma(n-1)$$
2. 當 $n \leq 1$ 時，返回 $n$ 作為遞迴的結束條件。  
3. 主程式呼叫遞迴函式，並輸出計算結果。

## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

int A(int m, int n) {
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return A(m - 1, 1);
    else
        return A(m - 1, A(m, n - 1));
}

int main() {
    cout << A(1, 2) << endl; // 預期輸出：4
    return 0;
}

```

## 效能分析

1.時間複雜度

Ackermann 函數的成長速度極快，
其遞迴次數遠遠超過多項式或指數等常見函數的增長率，因此無法以封閉式時間複雜度表示。
不過，若將 m 固定於小範圍，可以觀察其具體行為：

當 m = 0 時：僅執行一次簡單加法運算 → 時間為常數階。

當 m = 1 或 m = 2 時：整體運算量與 n 成線性關係。

當 m = 3 時：結果呈指數爆炸（以 2 為底的指數增長）。

當 m ≥ 4 時：遞迴深度與時間成長已遠超指數級，實務上無法計算。

2.空間複雜度

Ackermann 函數的每一層遞迴都會在系統堆疊中保留一個呼叫紀錄。因此其空間使用量與遞迴深度呈正比。  

當輸入的 `m` 與 `n` 增加時，堆疊深度急劇增加，最終可能導致 **Stack Overflow**。

由於每一層的狀態（m, n）需保留至子呼叫完成後才能回傳，故堆疊深度與遞迴層數呈正比。

以下為不同 `m` 值下的近似空間複雜度：
| m | 主要成長形態 | 空間複雜度 | 備註 |
|:-:|:--|:--|:--|
| 0 | 常數 | `O(1)` | 無遞迴呼叫 |
| 1 | 線性 | `O(n)` | 呼叫深度約等於 n |
| 2 | 線性 | `O(n)` | 每層結束即返回 |
| 3 | 指數 | `O(2^n)` | 呼叫深度隨結果倍增 |
| ≥4 | 超指數 | 無法估計 | 系統堆疊極速溢出 |

## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $n$ | 預期輸出 | 實際輸出 |
|:--------:|:------------:|:--------:|:--------:|
| 測試一 | $n = 0$ | 0 | 0 |
| 測試二 | $n = 1$ | 1 | 1 |
| 測試三 | $n = 3$ | 6 | 6 |
| 測試四 | $n = 5$ | 15 | 15 |
| 測試五 | $n = -1$ | 異常拋出 | 異常拋出 |


### 編譯與執行指令
```shell
$ g++ Problem1-1.cpp -std=c++14 -o Problem1-1 (Visual Studio 2022 為C+14)
$ Problem1-1.exe
4
```

### 結論

1.在撰寫 Ackermann 函數的過程中，我是根據題目給的定義式，直接把三種情況分別寫進遞迴函式裡：  
`m == 0` 回傳 `n + 1`，`n == 0` 呼叫 `A(m - 1, 1)`，其他情況則是再呼叫一次 `A(m - 1, A(m, n - 1))`。  

2.實作時可以明顯感受到這題的遞迴層數非常深，雖然在小數值下（像 `(1,2)`、`(2,2)`、`(3,2)`）都能正確算出結果，但只要 `m` 稍微變大，執行時間就會變得非常慢，甚至造成 **Stack Overflow**。  

3.這題讓我更清楚理解「遞迴呼叫其實就是一層層函式堆疊」的概念，每一次的呼叫都必須等內層結束才能往回傳值。  
雖然這個函數在實務上不太會被用到，但它很好地展示了遞迴的運作方式，以及遞迴演算法的極限。
## 申論及開發報告

### 選擇遞迴的原因

在這題中，我選擇使用遞迴的主要原因是 Ackermann 函數本身就是用遞迴定義的。  
用遞迴方式撰寫可以讓程式的結構幾乎完全對應數學公式，每一個條件判斷都能清楚表示出函式的三種情況。  

1. **程式邏輯簡單直觀**  
  Ackermann 函數的數學定義本身就是一種典型的遞迴關係式，使用遞迴實作能自然地表達「將問題拆解為更小的子問題」這個核心概念。



3. **易於理解與實現**  
   遞迴的程式碼更接近數學公式的表示方式，特別適合新手學習遞迴的基本概念。  
   以本程式為例：  

   ```cpp
   int sigma(int n) {
       if (n < 0)
           throw "n < 0";
       else if (n <= 1)
           return n;
       return n + sigma(n - 1);
   }
   ```
   # Ackermann 函數（非遞迴版本）
   
   ## 解題說明

Ackermann 函數的遞迴版本在邏輯上簡潔，但由於呼叫層數極深，在輸入稍大的情況下容易導致 **Stack Overflow**。  

因此，本題實作一個「**非遞迴版本**」的 Ackermann 函數，透過手動模擬呼叫堆疊的方式，避免系統堆疊限制。

## 解題策略
   1. 使用結構 `Frame` 模擬函式呼叫的狀態，包含：
   - `m`、`n`：對應函式的參數；
   - `stage`：記錄是否已處理過內層遞迴。

2. 使用陣列作為**手動堆疊（stack）**：
   - 以 `push`（top++）與 `pop`（top--）模擬系統的呼叫與返回。
   - 當 `m==0` 時直接計算結果並回傳。
   - 若 `n==0` 或尚未處理內層函式，則依定義式將下一層呼叫壓入堆疊。

3. 透過 while 迴圈不斷模擬「遞迴展開與回傳」的過程，最終回傳計算結果。
   
## 程式實作
```cpp
#include <iostream>
using namespace std;

struct Frame {
    int m, n, stage;
};
const int MAX = 100000;
Frame st[MAX];
int top = -1;

int A_iter(int m, int n) {
    int result = 0;
    top = -1;
    st[++top] = { m, n, 0 };
    while (top >= 0) {
        Frame cur = st[top--];

        if (cur.m == 0) {
            result = cur.n + 1;
            continue;
        }

        if (cur.n == 0) {
            st[++top] = { cur.m - 1, 1, 0 };
            continue;
        }

        if (cur.stage == 0) {
            st[++top] = { cur.m, cur.n, 1 };
            st[++top] = { cur.m, cur.n - 1, 0 };
        } else {
            st[++top] = { cur.m - 1, result, 0 };
        }
    }
    return result;
}

int main() {
    cout << A_iter(1, 2); // 預期輸出：4
    return 0;
}

```

## 效能分析

1. **時間複雜度（Time Complexity）**

   Ackermann 函數的成長速度極快，遠超一般多項式或指數函數。  
   對於固定的 `m`，其遞迴次數（或堆疊模擬次數）成長情形如下：

   - 當 `m = 0` 時，函數僅需一次計算 `n + 1`，為 **O(1)**。  
   - 當 `m = 1` 或 `m = 2` 時，函數呈現線性增長，為 **O(n)**。  
   - 當 `m = 3` 時，成長速度接近指數級，約為 **O(2ⁿ)**。  
   - 當 `m ≥ 4` 時，函數值增長極為劇烈，已超出可實際運算範圍。  

   下表為各層 `m` 的公式與近似時間複雜度：

   | m | 定義公式 | 成長型態 | 時間複雜度 |
   |:-:|:--|:--|:--|
   | 0 | A(0, n) = n + 1 | 常數成長 | O(1) |
   | 1 | A(1, n) = n + 2 | 線性成長 | O(n) |
   | 2 | A(2, n) = 2n + 3 | 線性成長 | O(n) |
   | 3 | A(3, n) = 2^(n+3) - 3 | 指數成長 | O(2ⁿ) |

   因此，即使在非遞迴版本中，整體運算時間仍隨輸入急速增加，無法有效以多項式近似。

2. **空間複雜度（Space Complexity）**

   非遞迴版本透過陣列模擬系統呼叫堆疊，雖可避免系統 Stack Overflow，但仍需為每層函式呼叫儲存狀態。  
   若最大堆疊深度為 `d`，其空間複雜度為 **O(d)**。  

   依輸入情況可得下表：

   | 輸入 (m, n) | 模擬堆疊最大深度 d | 空間複雜度 |
   |:--:|:--:|:--:|
   | (0, n) | 1 | O(1) |
   | (1, n) | n | O(n) |
   | (2, n) | n | O(n) |
   | (3, n) | 2ⁿ | O(2ⁿ) |

   當 `m` 或 `n` 增大時，儲存的 Frame 數量將急速增加，雖不會立即導致系統崩潰，但仍可能超出陣列 `MAX` 的範圍。
   因此在實作時需對輸入範圍進行限制，以確保記憶體使用安全。

   ## 測試與驗證
   
   ### 測試案例
| 測試案例 | 輸入參數 (m, n) | 預期輸出 | 實際輸出 | 說明 |
|:--:|:--:|:--:|:--:|:--|
| 測試一 | (0, 0) | 1 | 1 | 基底情況，直接回傳 n + 1 |
| 測試二 | (1, 2) | 4 | 4 | 確認線性遞增公式 A(1, n) = n + 2 |
| 測試三 | (2, 2) | 7 | 7 | 驗證多層呼叫邏輯一致性 |
| 測試四 | (3, 2) | 29 | 29 | 深層遞迴模擬正確，堆疊穩定 |
| 測試五 | (4, 1) | 65533 | 65533 | 高層級輸入，計算緩慢但正確 |

### 編譯與執行指令
```shell
$ g++ Problem1-1.cpp -std=c++14 -o Problem1-1 (Visual Studio 2022 為C+14)
$ Problem1-1.exe
4
```
## 結論
與遞迴版本相比，本演算法的主要差異在於：  
1. 以迴圈取代系統遞迴呼叫，能有效避免 **Stack Overflow**。  
2. 程式邏輯更為複雜，但可清楚觀察每層函式呼叫的推入與彈出過程。  
3. 在時間與空間複雜度上，雖未能降低 Ackermann 函數的爆炸性成長，但提升了執行穩定性與可控性。

## 申論及開發報告

### 選擇非遞迴方式的原因

本題選擇以「非遞迴」方式實作 Ackermann 函數，主要是為了解決遞迴版本在執行過程中可能發生的 **Stack Overflow** 問題。  
由於 Ackermann 函數的呼叫層數隨輸入值急遽上升，當系統堆疊空間不足時，遞迴版本會強制終止。 

1. **程式邏輯清楚直觀**
   Ackermann 函數的定義本身就具備明確的條件結構，非遞迴版本的程式設計以此為基礎，透過 **堆疊模擬遞迴展開**，使整體邏輯保持清楚且易於追蹤。
   
#作業2 PowerSet（冪集合）
   
## 解題說明

本題要求撰寫一個遞迴函式，列舉集合 S 的所有子集合（Power Set）。  
若集合 S 含有 n 個元素，則 PowerSet(S) 為所有可能子集合所組成的集合。

## 解題策略

1. **遞迴思維建立**  
   將集合 S 視為由 n 個元素組成，對於每個元素有兩種選擇：「包含」或「不包含」。  
   這是一個典型的二元遞迴問題。  

## 程式實作
```cpp
#include <iostream>
#include <string>
using namespace std;

void PowerSet(string a, int index, string current) {
    // 遞迴終止條件：處理完所有元素
    if (index == set.size()) {
        cout << "{" << current << "}" << endl;
        return;
    }

    // 不包含目前元素
    PowerSet(a, index + 1, current);

    // 包含目前元素
    PowerSet(a, index + 1, current + set[index]);
}

int main() {
    string s;
    cin >>s;
    PowerSet(s, 0, "");
    return 0;
}


```

## 效能分析

1. **時間複雜度（Time Complexity）**

   PowerSet 的核心邏輯是「每個元素都有取或不取兩種選擇」，因此對於 n 個元素的集合，總共會產生 $2^n$ 個子集合。  
   每一次遞迴呼叫都對應一次「包含／不包含」的決策，且每層遞迴皆需輸出結果或繼續展開。  

   | 項目 | 說明 | 複雜度 |
   |:--:|:--|:--:|
   | 遞迴呼叫次數 | 每個元素有兩種可能 | $2^n$ |
   | 每次處理時間 | 常數時間（O(1)） | O(1) |
   | **總時間複雜度** | 所有遞迴展開的總和 | **O(2ⁿ)** |

   2. **空間複雜度（Space Complexity）**

   在遞迴過程中，每一層函式呼叫都會暫存一個狀態（`current` 字串與 `index`），  
   遞迴深度等於集合大小 n，  
   故堆疊所需空間為 O(n)。
   
   | 項目 | 說明 | 複雜度 |
   |:--:|:--|:--:|
   | 遞迴深度 | 每次呼叫多一層 | O(n) |
   | 結果儲存（若保存全部子集合） | 需同時儲存 $2^n$ 組資料 | O(n × 2ⁿ) |
   | **實際空間使用（即時輸出）** | 僅使用遞迴堆疊 | **O(n)** |

   ## 測試與驗證

為驗證本程式的正確性與遞迴展開邏輯，針對不同長度的輸入字串進行測試，觀察其輸出是否涵蓋所有可能的子集合。  
所有測試皆以即時輸出（逐行列印）方式執行，不進行結果儲存，以避免不必要的空間消耗。

### 測試案例

| 測試案例 | 輸入字串 s | 預期輸出 | 實際輸出 | 備註 |
|:--:|:--:|:--|:--|:--|
| 測試一 | `""`（空字串） | `""`（僅空集合） | `""` | 基底情況，無元素 |
| 測試二 | `"a"` | `""`, `"a"` | 相同 | 兩種子集合：取與不取 |
| 測試三 | `"ab"` | `""`, `"b"`, `"a"`, `"ab"` | 相同 | 驗證雙層遞迴展開 |
| 測試四 | `"abc"` | `""`, `"c"`, `"b"`, `"bc"`, `"a"`, `"ac"`, `"ab"`, `"abc"` | 相同 | 題目範例 |
| 測試五 | `"abcd"` | 共 16 種子集合 | 共 16 種子集合 | 驗證指數成長趨勢 |

## 結論

本程式透過遞迴的方式，成功列舉出輸入字串中所有可能的子集合（Power Set）。  
程式邏輯簡潔，能夠自然地對應到「每個元素取或不取」的數學定義。  

從測試結果可觀察到：  
1. 在小規模輸入下（如 `"ab"`、`"abc"`），輸出完整且符合理論結果。  
2. 遞迴層數與輸出數量皆隨輸入長度 n 以指數成長，執行效率雖下降，但能充分展示遞迴展開的特性。  
3. 每一層遞迴皆對應一次決策分支，整體結構清晰且可讀性高。

## 申論及開發報告

### 選擇遞迴方式的原因

在本題中選擇以遞迴方式實作 PowerSet，主要是因為冪集合的數學定義本身就具備遞迴結構。
其中每個元素都有兩種狀態：「取」或「不取」。  
此性質非常適合用遞迴方式展開，每次呼叫函式都對應一層「包含／排除」的決策，使程式結構自然對應數學推導。  
